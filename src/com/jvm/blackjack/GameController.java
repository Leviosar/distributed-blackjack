package com.jvm.blackjack;

import org.jgroups.*;
import org.jgroups.util.Util;

import java.io.*;
import java.util.*;
import java.util.concurrent.Semaphore;

public class GameController implements Receiver {

    // Deck of cards, shared between instances
    private LinkedList<Card> cards;

    // Local instance player's hand
    private LinkedList<Card> playerHand;

    // Local list of scoreboard for final hands
    private LinkedList<Integer> scoreboard;

    // List of strings for state sharing between instances
    private final LinkedList<String> state = new LinkedList<>();

    // Atomic lock for turn based gameplay
    private Semaphore turnLock;

    // Communication channel provided by JGroups
    private JChannel channel;

    // Current view of the communication channel
    private View view;

    // Index of the player currently playing
    private Integer currentTurnId;

    // Index of this instance player
    private Integer currentPlayerId;

    // Game over flag
    private Boolean gameOver = false;

    // Turn over flag
    private Boolean stopped = false;

    GameController() {
        try {
            this.turnLock = new Semaphore(0);
            this.playerHand = new LinkedList<>();
            this.cards = new LinkedList<>();
            this.scoreboard = new LinkedList<>();
            this.currentTurnId = 0;

            this.channel = new JChannel().setReceiver(this);
            this.channel.connect("blackjack");

            if (this.view != null) {
                this.currentPlayerId = view.getMembers().size() - 1;
            }

            this.channel.getState(null, 10000);

            if (Util.isCoordinator(this.channel)) {
                this.cards = Card.generateDeck();
                this.serializeState();
                this.turnLock.release(1);
            } else {
                System.out.println("Você está na fila para jogar, espere a sua vez!");
            }

            this.gameLoop();
            this.channel.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    // Sends a string message through the communication channel and updates the application's state
    private void sendMessage(String text) {
        try {
            Message message = new ObjectMessage(null, text);
            this.channel.send(message);
            this.serializeState();
        } catch (Exception e) {
            System.out.println("Ocorreu um erro ao enviar mensagem para o grupo");
        }
    }

    // Event triggered when a new view is generated by Jgroups. Normally this happens when a new instance joins the channel
    public void viewAccepted(View view) {
        boolean left = (this.view != null) && view.getMembers().size() < this.view.getMembers().size();

        if (left) {
            Address instanceAddress = this.view.getMembers().get(this.currentPlayerId);

            for (int i = 0; i < view.getMembers().size(); i++) {
                Address member = view.getMembers().get(i);
                if (instanceAddress.compareTo(member) == 0) {
                    this.currentPlayerId = i;
                }
            }

            if (this.currentTurnId >= view.getMembers().size()) {
                this.currentTurnId = 0;
            }

            if (this.isMyTurn()) {
                this.turnLock.release(1);
            }
        } else {
            while (this.scoreboard.size() < view.getMembers().size()) {
                this.scoreboard.add(0);
            }
        }

        this.view = view;
    }

    // Event triggered when a new message is received by the instance
    public void receive(Message message) {
        String content = message.getObject();

        if (this.view != null) {
            int id = view.getMembers().indexOf(message.getSrc());

            if (id != this.currentTurnId) {
                return;
            }

            if (content.contains("Card.draw")) {
                Integer value = Integer.parseInt(content.split(" : ")[1]);
                this.scoreboard.set(id, this.scoreboard.get(id) + value);
                this.cards.remove(0);
                if (id != this.currentPlayerId) {
                    System.out.println("Jogador #" + id + " comprou uma carta (" + value + ")");
                }
            } else if (content.contains("Turn.end")) {
                this.currentTurnId = (this.currentTurnId + 1) % this.view.getMembers().size();
                this.turnLock.release(1);

                if (id != this.currentPlayerId) {
                    System.out.println("Jogador #" + id + " passsou, o próximo a jogar é o jogador #" + this.currentTurnId.toString());
                } else {
                    System.out.println("Você passou, agora espere os outros jogadores concluírem suas jogadas!");
                }
            } else if (content.contains("Game.end")) {
                this.gameOver = true;
            }
        }
    }

    // Serialize object's properties into lists of strings that can be emitted on Jgroups streams
    private void serializeState() {
        StringBuilder deck = new StringBuilder();
        for (Card card : this.cards) {
            deck.append(card.value).append(",");
        }

        String turn = this.currentTurnId.toString();

        synchronized (this.state) {
            this.state.clear();
            this.state.add(deck.toString());
            this.state.add(turn);
        }
    }

    // Inserts the current instance state on an output stream
    public void getState(OutputStream output) throws Exception {
        synchronized (this.state) {
            Util.objectToStream(this.state, new DataOutputStream(output));
        }
    }

    // Parses the state coming from an input stream into instance properties
    public void setState(InputStream input) throws Exception {
        List<String> list = Util.objectFromStream(new DataInputStream(input));

        synchronized (this.state) {
            this.state.clear();
            this.state.addAll(list);
        }

        this.cards.clear();
        String parsedDeck = this.state.get(0);

        if (parsedDeck.length() > 0) {
            for (String item : parsedDeck.split(",")) {
                this.cards.add(new Card(Integer.parseInt(item)));
            }
        }

        String parsedTurn = state.get(1);
        if (parsedTurn.length() > 0) {
            this.currentTurnId = Integer.parseInt(parsedTurn);
        }
    }

    // Checks if the instance user is the current player
    Boolean isMyTurn() {
        return Objects.equals(this.currentTurnId, this.currentPlayerId);
    }

    // Emit an event of card drawing into the communication group, if the deck is empty exits the application
    Card drawCard() {
        if (this.cards.isEmpty()) {
            System.out.println("O deck está vazio, isso aqui não deveria acontecer...");
            System.exit(1);
            return new Card(0);
        } else {
            Card card = this.cards.get(0);
            this.sendMessage("Card.draw : " + card.value);
            return card;
        }
    }

    // Print CLI hints for player
    void showAvailablePlays() {
        System.out.println("1 - Comprar");
        System.out.println("2 - Passar");
        System.out.println("3 - Sair");
        System.out.print("Escolha sua ação > ");
    }

    // Get the total amount of card values on player's hand
    Integer sumPlayerHand() {
        Integer sum = 0;

        for (Card card : this.playerHand) {
            sum += card.value;
        }

        return sum;
    }

    // Prints the current state of the player's hand
    void showPlayerHand() {
        String output = "Total na mão: ";

        Integer sum = 0;
        for (Card card : this.playerHand) {
            sum += card.value;
        }

        output += sum.toString();

        System.out.println(output);
    }

    // Emits an event for the end of the game, usually when the last player passes its turn, but can also occur when any player hits 21
    void endGame() {
        this.gameOver = true;
        this.sendMessage("Game.end");
    }

    // Emits an event for the end of the turn, if the player emitting is the last player of the table, redirects the event to endGame()
    void endTurn() {
        this.scoreboard.set(this.currentPlayerId, this.sumPlayerHand());

        if (this.currentTurnId == this.view.getMembers().size() - 1) {
            this.endGame();
        } else {
            this.stopped = true;
            this.sendMessage("Turn.end");
        }
    }

    // Determinate the game's winner, by comparing all the scores from local scoreboard
    void calculateWinner() {
        Integer max = Collections.max(this.scoreboard);
        ArrayList<Integer> occurrences = new ArrayList<>();

        for (int i = 0; i < this.scoreboard.size(); i++) {
            if (Objects.equals(this.scoreboard.get(i), max)) {
                occurrences.add(i);
            }
        }

        StringBuilder output = new StringBuilder();

        if (occurrences.size() == 1) {
            output.append("O ganhador é o jogador #").append(occurrences.get(0)).append("!");
        } else {
            output.append("E os ganhadores, empatados, foram: ");
            for (int i = 0; i < occurrences.size(); i++) {
                output.append("#").append(occurrences.get(i));
                if (!(i == occurrences.size() - 1)) {
                    output.append(", ");
                }
            }
        }

        System.out.println(output);
    }

    // The applications central game loop, while the game is not over, cycles through all the players on the table
    // one at a time, allowing them to take actions using stdin until certain conditions are reached.

    // The available actions are:
    // 1 - Draw a new card
    // 2 - Stop at current value
    // 3 - Leave the application

    // If a player hits exactly 21 points, the game is over with the current player being called winner.
    // If a player exceeds 21 points, their turn is over and the application passes the turn to the next player (if any).
    // If a player calls to stop, the applications passes the turn to the next player (if any).

    // When the turnLoop is broken, the application will wait til the gameLoop is also broken, then the final score will
    // be calculated using calculateWinner() function.
    void gameLoop() {
        Scanner input = new Scanner(System.in);

        while (!this.gameOver) {
            try {
                this.turnLock.acquire(1);
            } catch (InterruptedException e) {
                System.out.println("Ocorreu um erro ao tentar passar no semáforo.");
                System.exit(1);
            }

            while (this.isMyTurn() && !this.stopped) {
                System.out.println("Jogador #" + this.currentTurnId);

                if (!this.playerHand.isEmpty()) {
                    this.showPlayerHand();
                }

                this.showAvailablePlays();
                String play = input.nextLine();

                if (play.contains("1")) {
                    this.playerHand.add(this.drawCard());

                    if (this.sumPlayerHand() == 21) {
                        this.endGame();
                        break;
                    } else if (this.sumPlayerHand() > 21) {
                        this.endTurn();
                        break;
                    }
                }

                if (play.contains("2")) {
                    this.endTurn();
                    break;
                }

                if (play.contains("3")) {
                    System.out.println("Saindo da sala...");
                    System.exit(0);
                }
            }
        }

        this.calculateWinner();
    }
}
